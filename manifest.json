{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"ProfitJava6.java:9: error: no suitable method found for timedJava6(String,<anonymous MySupplier<Double>>)\n    final Double costs = Timing.timedJava6(\"ProfitJava6: Cost calculation\",\n                               ^\n    method Timing.<A#1>timedJava6(String,Supplier<A#1>) is not applicable\n      (cannot infer type-variable(s) A#1\n        (argument mismatch; <anonymous MySupplier<Double>> cannot be converted to Supplier<A#1>))\n    method Timing.<A#2>timedJava6(String,MyFunction<String,Void>,Supplier<A#2>) is not applicable\n      (cannot infer type-variable(s) A#2\n        (actual and formal argument lists differ in length))\n  where A#1,A#2 are type-variables:\n    A#1 extends Object declared in method <A#1>timedJava6(String,Supplier<A#1>)\n    A#2 extends Object declared in method <A#2>timedJava6(String,MyFunction<String,Void>,Supplier<A#2>)\nProfitJava6.java:17: error: no suitable method found for timedJava6(String,<anonymous MySupplier<Double>>)\n    final Double revenue = Timing.timedJava6(\"ProfitJava6: Revenue calculation\",\n                                 ^\n    method Timing.<A#1>timedJava6(String,Supplier<A#1>) is not applicable\n      (cannot infer type-variable(s) A#1\n        (argument mismatch; <anonymous MySupplier<Double>> cannot be converted to Supplier<A#1>))\n    method Timing.<A#2>timedJava6(String,MyFunction<String,Void>,Supplier<A#2>) is not applicable\n      (cannot infer type-variable(s) A#2\n        (actual and formal argument lists differ in length))\n  where A#1,A#2 are type-variables:\n    A#1 extends Object declared in method <A#1>timedJava6(String,Supplier<A#1>)\n    A#2 extends Object declared in method <A#2>timedJava6(String,MyFunction<String,Void>,Supplier<A#2>)\nProfitJava6.java:25: error: no suitable method found for timedJava6(String,MyFunction<String,Void>,<anonymous MySupplier<Double>>)\n    final Double profit = Timing.timedJava6(\"ProfitJava6: Profit calculation\",\n                                ^\n    method Timing.<A#1>timedJava6(String,Supplier<A#1>) is not applicable\n      (cannot infer type-variable(s) A#1\n        (actual and formal argument lists differ in length))\n    method Timing.<A#2>timedJava6(String,MyFunction<String,Void>,Supplier<A#2>) is not applicable\n      (cannot infer type-variable(s) A#2\n        (argument mismatch; <anonymous MySupplier<Double>> cannot be converted to Supplier<A#2>))\n  where A#1,A#2 are type-variables:\n    A#1 extends Object declared in method <A#1>timedJava6(String,Supplier<A#1>)\n    A#2 extends Object declared in method <A#2>timedJava6(String,MyFunction<String,Void>,Supplier<A#2>)\n3 errors\n","instructions":"Java Functional Programming by Jessica Kerr\n\nmodule 2\n\nfunctional programming with java\n  C24C65, tuna, fpwj-original\n  4DAE5E, starfish, fpwj-functionsAsValues\n  BDA089, snake, fpwj-functionsReturningFunctions\n  D96026, salmon, fpwj-typeSafe\n  02DB89, vulture, fpwj-java6\n  23EB21, lobster, fpwj-m2\n","ProfitBefore.java":"\nimport java.util.logging.Logger;\nimport java.util.Random;\n\npublic class ProfitBefore {\n    static final Logger logger = \n        Logger.getLogger(ProfitBefore.class.getName());\n\n    public static Double calculate() {\n\n        final Double costs = calculateCosts();\n\n        final Double revenue = calculateRevenue();\n\n        final Double profit = calculateProfit(costs, revenue);\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 200;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            logger.severe(\"Work was interrupted. Exception message: \" + \n                e.toString());\n        }\n    }\n}","ProfitNaive.java":"import java.util.logging.Logger;\nimport java.util.Random;\nimport java.util.Date;\n\npublic class ProfitNaive {\n  static final Logger logger = \n    Logger.getLogger(ProfitNaive.class.getName());\n\n  public static Double calculate() {\n\n    final Date beforeCosts = new Date();\n    final Double costs = calculateCosts();\n    final Long costsDuration =\n            new Date().getTime() - beforeCosts.getTime();\n    System.out.println(\n            \"ProfitNaive: Cost calculation took \" + costsDuration + \" ms\");\n\n\n    final Date beforeRevenue = new Date();\n    final Double revenue = calculateRevenue();\n    final Long revenueDuration =\n            new Date().getTime() - beforeRevenue.getTime();\n    System.out.println(\n            \"ProfitNaive: Revenue calculation took \" + revenueDuration + \" ms\");\n\n\n    final Date beforeProfit = new Date();\n    final Double profit = calculateProfit(costs, revenue);\n    final Long profitDuration =\n            new Date().getTime() - beforeProfit.getTime();\n    System.out.println(\n            \"ProfitNaive: Profit calculation took \" + profitDuration + \" ms\");\n\n    return profit;\n\n  }\n\n\n  private static Double calculateCosts() {\n    pretendToWorkHard();\n    return 4567.3;\n  }\n\n  private static Double calculateRevenue() {\n    pretendToWorkHard();\n    return 23413.2;\n  }\n\n  private static Double calculateProfit(Double costs, Double revenue) {\n    pretendToWorkHard();\n    return revenue - costs;\n  }\n\n  private static final Random r = new Random();\n  private static final Integer MAX_WORK_TIME_MS = 200;\n\n  private static void pretendToWorkHard() {\n    try {\n      Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n    } catch (InterruptedException e) {\n        logger.severe(\"Work was interrupted. Exception message: \" + \n            e.toString());\n    }\n  }\n}","ProfitTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class ProfitTest {\n\n    @Test\n    public void ProfitBefore_should_calculate_profits() {\n        assertEquals(18845.9, ProfitBefore.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitNaive_should_calculate_profits() {\n        assertEquals(18845.9, ProfitNaive.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitDeduplicate_should_calculate_profits() {\n        assertEquals(18845.9, ProfitDeduplicate.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitGeneralize_should_calculate_profits() {\n        assertEquals(18845.9, ProfitGeneralize.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitIsolation_should_calculate_profits() {\n        assertEquals(18845.9, ProfitIsolation.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitJava6_should_calculate_profits() {\n        assertEquals(18845.9, ProfitJava6.calculate(), 0.001);\n    }\n}\n","ProfitDeduplicate.java":"import java.util.logging.Logger;\nimport java.util.Random;\n\npublic class ProfitDeduplicate {\n    static final Logger logger = \n        Logger.getLogger(ProfitDeduplicate.class.getName());\n\n    public static Double calculate() {\n\n        final Double costs = Timing.timedDouble(\n                \"ProfitDeduplicate: Cost calculation\",\n                ProfitDeduplicate::calculateCosts);\n\n        final Double revenue = Timing.timedDouble(\n                \"ProfitDeduplicate: Revenue calculation\",\n                () -> calculateRevenue());\n\n        final Double profit = Timing.timedDouble(\n                \"ProfitDeduplicate: Profit calculation\",\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 200;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            logger.severe(\"Work was interrupted. Exception message: \" + \n                e.toString());\n        }\n    }\n}\n","Timing.java":"\nimport java.util.Date;\nimport java.util.function.Supplier;\nimport java.util.function.Consumer;\n\npublic class Timing {\n\n    public static Double timedDouble(String description, \n            Supplier<Double> code) {\n        final Date before = new Date();\n        final Double result = code.get();\n        final Long duration = new Date().getTime() - before.getTime();\n        System.out.println(description + \" took \" + duration + \" ms\");\n        return result;\n    }\n\n    public static <A> A timed(String description,\n                              Supplier<A> code) {\n        final Consumer<String> defaultPrinter = System.out::println;\n\n        // change default to do nothing \n        // final Consumer<String> defaultPrinter = (s) -> {};  \n\n        return timed(description, defaultPrinter, code);\n    }\n\n    public static <A> A timed(String description,\n                              Consumer<String> printer,\n                              Supplier<A> code) {\n        final Date before = new Date();\n\n        final A result = code.get();\n\n        final Long duration = new Date().getTime() - before.getTime();\n        printer.accept(description + \" took \" + duration + \" ms\");\n        return result;\n    }\n\n  private static MyFunction<String, Void> DO_NOTHING = \n    new MyFunction<String, Void>(){\n        @Override\n        public Void apply(String s) {\n          return null;\n        }\n  };\n\n  private static MyFunction<String, Void> PRINT_TO_STDOUT = \n    new MyFunction<String, Void>(){\n        @Override\n        public Void apply(String s) {\n          System.out.println(s);\n          return null;\n        }\n  };\n\n  public static <A> A timedJava6(String description,\n                            Supplier<A> code) {\n    return timedJava6(description, PRINT_TO_STDOUT, code);\n  }\n\n  public static <A> A timedJava6(String description,\n                            MyFunction<String, Void> output,\n                            Supplier<A> code) {\n\n    final Date before = new Date();\n    A result = code.get();\n    final Long duration = new Date().getTime() -\n            before.getTime();\n    output.apply(description + \" took \" + duration\n            + \" milliseconds\");\n\n    return result;\n  }\n}\n","ProfitGeneralize.java":"import java.util.logging.Logger;\nimport java.util.Random;\n\npublic class ProfitGeneralize {\n    static final Logger logger = \n        Logger.getLogger(ProfitGeneralize.class.getName());\n\n    public static Double calculate() {\n\n        final Double costs = Timing.timed(\n                \"ProfitGeneralize: Cost calculation\",\n                ProfitGeneralize::calculateCosts);\n\n        final Double revenue = Timing.timed(\n                \"ProfitGeneralize: Revenue calculation\",\n                ProfitGeneralize::calculateRevenue);\n\n        final Double profit = Timing.timed(\n                \"ProfitGeneralize: Profit calculation\",\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 200;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            logger.severe(\"Work was interrupted. Exception message: \" + \n                e.toString());\n        }\n    }\n}\n","ProfitIsolation.java":"\nimport java.util.logging.Logger;\nimport java.util.Random;\n\n\npublic class ProfitIsolation {\n    static final Logger logger = \n        Logger.getLogger(ProfitIsolation.class.getName());\n\n    public static Double calculate() {\n\n        final Double costs = Timing.timed(\n                \"ProfitIsolation: Cost calculation\",\n                ProfitIsolation::calculateCosts);\n\n        final Double revenue = Timing.timed(\n                \"ProfitIsolation: Revenue calculation\",\n                ProfitIsolation::calculateRevenue);\n\n        final Double profit = Timing.timed(\n                \"ProfitIsolation: Profit calculation\",\n                logger::info,\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 200;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            logger.severe(\"Work was interrupted. Exception message: \" + \n                e.toString());\n        }\n    }\n}\n","ProfitJava6.java":"import java.util.logging.Logger;\nimport java.util.Random;\n\npublic class ProfitJava6 {\n  static final Logger logger = Logger.getLogger(ProfitJava6.class.getName());\n\n  public static Double calculate() {\n\n    final Double costs = Timing.timedJava6(\"ProfitJava6: Cost calculation\",\n            new MySupplier<Double>() {\n              @Override\n              public Double get() {\n                return calculateCosts();\n              }\n            });\n\n    final Double revenue = Timing.timedJava6(\"ProfitJava6: Revenue calculation\",\n            new MySupplier<Double>() {\n              @Override\n              public Double get() {\n                return calculateRevenue();\n              }\n            });\n\n    final Double profit = Timing.timedJava6(\"ProfitJava6: Profit calculation\",\n            LoggerFunctions.info(logger),\n            new MySupplier<Double>() {\n              @Override\n              public Double get() {\n                return calculateProfit(costs, revenue);\n              }\n            });\n\n    return profit;\n  }\n\n  private static Double calculateCosts() {\n    pretendToWorkHard();\n    return 4567.3;\n  }\n\n  private static Double calculateRevenue() {\n    pretendToWorkHard();\n    return 23413.2;\n  }\n\n  private static Double calculateProfit(Double costs, Double revenue) {\n    pretendToWorkHard();\n    return revenue - costs;\n  }\n\n  private static final Random r = new Random();\n  private static final Integer MAX_WORK_TIME_MS = 200;\n  private static void pretendToWorkHard() {\n    try {\n      Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n    } catch (InterruptedException e) {\n    }\n  }\n}\n","MyFunction.java":"public interface MyFunction<T, R> {\n    R apply(T input);\n}","LoggerFunctions.java":"import java.util.logging.Logger;\n\npublic class LoggerFunctions {\n\n  public static MyFunction<String, Void> info(final Logger logger) {\n    return new MyFunction<String, Void>() {\n      @Override\n      public Void apply(String s) {\n        logger.info(s);\n        return null;\n      }\n    };\n  }\n}\n","MySupplier.java":"public interface MySupplier<T> {\n    public T get();\n}"}