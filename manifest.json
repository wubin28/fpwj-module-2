{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"ProfitDeduplicate.java:7: error: cannot find symbol\n        final Double costs = Timing.timedDouble(\n                             ^\n  symbol:   variable Timing\n  location: class ProfitDeduplicate\nProfitDeduplicate.java:16: error: incompatible types: unexpected return value\n        return profit;\n               ^\n2 errors\n","instructions":"Java Functional Programming by Jessica Kerr\n\nmodule 2\n\nfunctional programming with java\n  C24C65, tuna, fpwj-original\n  4DAE5E, starfish, fpwj-functionsAsValues\n  BDA089, snake, fpwj-functionsReturningFunctions\n  D96026, salmon, fpwj-typeSafe\n  02DB89, vulture, fpwj-java6\n  23EB21, lobster, fpwj-m2\n","ProfitBefore.java":"\nimport java.util.Random;\n\npublic class ProfitBefore {\n    public static Double calculate() {\n\n        final Double costs = calculateCosts();\n\n        final Double revenue = calculateRevenue();\n\n        final Double profit = calculateProfit(costs, revenue);\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 2000;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            System.out.println(\"Work was interrupted. Exception message: \" + \n                e.getMessage());\n        }\n    }\n}\n","ProfitNaive.java":"\nimport java.util.Random;\nimport java.util.Date;\n\npublic class ProfitNaive {\n\n  public static Double calculate() {\n\n    final Date beforeCosts = new Date();\n    final Double costs = calculateCosts();\n    final Long costsDuration =\n            new Date().getTime() - beforeCosts.getTime();\n    System.out.println(\n            \"Cost calculation took \" + costsDuration + \" ms\");\n\n\n    final Date beforeRevenue = new Date();\n    final Double revenue = calculateRevenue();\n    final Long revenueDuration =\n            new Date().getTime() - beforeRevenue.getTime();\n    System.out.println(\n            \"Revenue calculation took \" + revenueDuration + \" ms\");\n\n\n    final Date beforeProfit = new Date();\n    final Double profit = calculateProfit(costs, revenue);\n    final Long profitDuration =\n            new Date().getTime() - beforeProfit.getTime();\n    System.out.println(\n            \"Profit calculation took \" + profitDuration + \" ms\");\n\n    return profit;\n\n  }\n\n\n  private static Double calculateCosts() {\n    pretendToWorkHard();\n    return 4567.3;\n  }\n\n  private static Double calculateRevenue() {\n    pretendToWorkHard();\n    return 23413.2;\n  }\n\n  private static Double calculateProfit(Double costs, Double revenue) {\n    pretendToWorkHard();\n    return revenue - costs;\n  }\n\n  private static final Random r = new Random();\n  private static final Integer MAX_WORK_TIME_MS = 2000;\n\n  private static void pretendToWorkHard() {\n    try {\n      Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n    } catch (InterruptedException e) {\n        System.out.println(\"Work was interrupted. Exception message: \" + \n            e.getMessage());\n    }\n  }\n}\n","ProfitTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class ProfitTest {\n\n    @Test\n    public void ProfitBefore_should_calculate_profits() {\n        assertEquals(18845.9, ProfitBefore.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitNaive_should_calculate_profits() {\n        assertEquals(18845.9, ProfitNaive.calculate(), 0.001);\n    }\n\n}\n","ProfitDeduplicate.java":"\nimport java.util.Random;\n\npublic class ProfitDeduplicate {\n    public static void calculate() {\n\n        final Double costs = Timing.timedDouble(\n                \"Cost calculation\",\n                () -> calculateCosts());\n\n        // repeat\n        final Double revenue = calculateRevenue();\n\n        final Double profit = calculateProfit(costs, revenue);\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 2000;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n        }\n    }\n}\n"}