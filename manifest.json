{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"ProfitIsolation.java:10: error: non-static method getLogger(String) cannot be referenced from a static context\n    Logger logger = LogManager.getLogger(\"\");\n                              ^\nProfitIsolation.java:16: error: cannot find symbol\n                Example::calculateCosts);\n                ^\n  symbol:   variable Example\n  location: class ProfitIsolation\nProfitIsolation.java:20: error: cannot find symbol\n                Example::calculateRevenue);\n                ^\n  symbol:   variable Example\n  location: class ProfitIsolation\nProfitIsolation.java:22: error: method timed in class Timing cannot be applied to given types;\n        final Double profit = Timing.timed(\n                                    ^\n  required: String,Supplier<A>\n  found: String,logger::info,()->calcul[...]enue)\n  reason: cannot infer type-variable(s) A\n    (actual and formal argument lists differ in length)\n  where A is a type-variable:\n    A extends Object declared in method <A>timed(String,Supplier<A>)\nProfitIsolation.java:24: error: non-static variable logger cannot be referenced from a static context\n                logger::info,\n                ^\nProfitTest.java:28: error: method calculate in class ProfitIsolation cannot be applied to given types;\n        assertEquals(18845.9, ProfitIsolation.calculate(), 0.001);\n                                             ^\n  required: String[]\n  found: no arguments\n  reason: actual and formal argument lists differ in length\n6 errors\n","instructions":"Java Functional Programming by Jessica Kerr\n\nmodule 2\n\nfunctional programming with java\n  C24C65, tuna, fpwj-original\n  4DAE5E, starfish, fpwj-functionsAsValues\n  BDA089, snake, fpwj-functionsReturningFunctions\n  D96026, salmon, fpwj-typeSafe\n  02DB89, vulture, fpwj-java6\n  23EB21, lobster, fpwj-m2\n","ProfitBefore.java":"\nimport java.util.Random;\n\npublic class ProfitBefore {\n    public static Double calculate() {\n\n        final Double costs = calculateCosts();\n\n        final Double revenue = calculateRevenue();\n\n        final Double profit = calculateProfit(costs, revenue);\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 200;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            System.out.println(\"Work was interrupted. Exception message: \" + \n                e.getMessage());\n        }\n    }\n}\n","ProfitNaive.java":"\nimport java.util.Random;\nimport java.util.Date;\n\npublic class ProfitNaive {\n\n  public static Double calculate() {\n\n    final Date beforeCosts = new Date();\n    final Double costs = calculateCosts();\n    final Long costsDuration =\n            new Date().getTime() - beforeCosts.getTime();\n    System.out.println(\n            \"Cost calculation took \" + costsDuration + \" ms\");\n\n\n    final Date beforeRevenue = new Date();\n    final Double revenue = calculateRevenue();\n    final Long revenueDuration =\n            new Date().getTime() - beforeRevenue.getTime();\n    System.out.println(\n            \"Revenue calculation took \" + revenueDuration + \" ms\");\n\n\n    final Date beforeProfit = new Date();\n    final Double profit = calculateProfit(costs, revenue);\n    final Long profitDuration =\n            new Date().getTime() - beforeProfit.getTime();\n    System.out.println(\n            \"Profit calculation took \" + profitDuration + \" ms\");\n\n    return profit;\n\n  }\n\n\n  private static Double calculateCosts() {\n    pretendToWorkHard();\n    return 4567.3;\n  }\n\n  private static Double calculateRevenue() {\n    pretendToWorkHard();\n    return 23413.2;\n  }\n\n  private static Double calculateProfit(Double costs, Double revenue) {\n    pretendToWorkHard();\n    return revenue - costs;\n  }\n\n  private static final Random r = new Random();\n  private static final Integer MAX_WORK_TIME_MS = 200;\n\n  private static void pretendToWorkHard() {\n    try {\n      Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n    } catch (InterruptedException e) {\n        System.out.println(\"Work was interrupted. Exception message: \" + \n            e.getMessage());\n    }\n  }\n}\n","ProfitTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class ProfitTest {\n\n    @Test\n    public void ProfitBefore_should_calculate_profits() {\n        assertEquals(18845.9, ProfitBefore.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitNaive_should_calculate_profits() {\n        assertEquals(18845.9, ProfitNaive.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitDeduplicate_should_calculate_profits() {\n        assertEquals(18845.9, ProfitDeduplicate.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitGeneralize_should_calculate_profits() {\n        assertEquals(18845.9, ProfitGeneralize.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitIsolation_should_calculate_profits() {\n        assertEquals(18845.9, ProfitIsolation.calculate(), 0.001);\n    }\n\n}\n","ProfitDeduplicate.java":"\nimport java.util.Random;\n\npublic class ProfitDeduplicate {\n    public static Double calculate() {\n\n        final Double costs = Timing.timedDouble(\n                \"Cost calculation\",\n                ProfitDeduplicate::calculateCosts);\n\n        final Double revenue = Timing.timedDouble(\n                \"Revenue calculation\",\n                () -> calculateRevenue());\n\n        final Double profit = Timing.timedDouble(\n                \"Profit calculation\",\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 200;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            System.out.println(\"Work was interrupted. Exception message: \" + \n                e.getMessage());\n        }\n    }\n}\n","Timing.java":"\nimport java.util.Date;\nimport java.util.function.Supplier;\n\npublic class Timing {\n\n    public static Double timedDouble(String description, Supplier<Double> code) {\n        final Date before = new Date();\n        final Double result = code.get();\n        final Long duration = new Date().getTime() - before.getTime();\n        System.out.println(description + \" took \" + duration + \" ms\");\n        return result;\n    }\n\n    public static <A> A timed(String description,\n                              Supplier<A> code) {\n        final Date before = new Date();\n\n        final A result = code.get();\n\n        final Long duration = new Date().getTime() - before.getTime();\n        System.out.println(description + \" took \" + duration + \" ms\");\n        return result;\n    }\n}\n","ProfitGeneralize.java":"\nimport java.util.Random;\n\npublic class ProfitGeneralize {\n    public static Double calculate() {\n\n        final Double costs = Timing.timed(\n                \"Cost calculation\",\n                ProfitGeneralize::calculateCosts);\n\n        final Double revenue = Timing.timed(\n                \"Revenue calculation\",\n                ProfitGeneralize::calculateRevenue);\n\n        final Double profit = Timing.timed(\n                \"Profit calculation\",\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 2000;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            System.out.println(\"Work was interrupted. Exception message: \" + \n                e.getMessage());\n        }\n    }\n}\n","ProfitIsolation.java":"\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\nimport java.util.Random;\n\n\npublic class ProfitIsolation {\n\n    Logger logger = LogManager.getLogger(\"\");\n\n    public static Double calculate(final String[] args) {\n\n        final Double costs = timed(\n                \"Cost calculation\",\n                Example::calculateCosts);\n\n        final Double revenue = timed(\n                \"Revenue calculation\",\n                Example::calculateRevenue);\n\n        final Double profit = Timing.timed(\n                \"Profit calculation\",\n                logger::info,\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 2000;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n        }\n    }\n}\n"}