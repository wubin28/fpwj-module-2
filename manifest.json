{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"Feb 10, 2016 6:12:08 AM ProfitIsolation$$Lambda$10/1768305536 accept\nINFO: Profit calculation took 387 ms\nJUnit version 4.11-SNAPSHOT-20120416-1530\n..Cost calculation took 47 ms\nRevenue calculation took 128 ms\nProfit calculation took 137 ms\n..Cost calculation took 116 ms\nRevenue calculation took 49 ms\nProfit calculation took 68 ms\n.\nTime: 4.314\n\nOK (5 tests)\n\n","instructions":"Java Functional Programming by Jessica Kerr\n\nmodule 2\n\nfunctional programming with java\n  C24C65, tuna, fpwj-original\n  4DAE5E, starfish, fpwj-functionsAsValues\n  BDA089, snake, fpwj-functionsReturningFunctions\n  D96026, salmon, fpwj-typeSafe\n  02DB89, vulture, fpwj-java6\n  23EB21, lobster, fpwj-m2\n","ProfitBefore.java":"\nimport java.util.Random;\n\npublic class ProfitBefore {\n    public static Double calculate() {\n\n        final Double costs = calculateCosts();\n\n        final Double revenue = calculateRevenue();\n\n        final Double profit = calculateProfit(costs, revenue);\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 200;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            System.out.println(\"Work was interrupted. Exception message: \" + \n                e.getMessage());\n        }\n    }\n}\n","ProfitNaive.java":"\nimport java.util.Random;\nimport java.util.Date;\n\npublic class ProfitNaive {\n\n  public static Double calculate() {\n\n    final Date beforeCosts = new Date();\n    final Double costs = calculateCosts();\n    final Long costsDuration =\n            new Date().getTime() - beforeCosts.getTime();\n    System.out.println(\n            \"Cost calculation took \" + costsDuration + \" ms\");\n\n\n    final Date beforeRevenue = new Date();\n    final Double revenue = calculateRevenue();\n    final Long revenueDuration =\n            new Date().getTime() - beforeRevenue.getTime();\n    System.out.println(\n            \"Revenue calculation took \" + revenueDuration + \" ms\");\n\n\n    final Date beforeProfit = new Date();\n    final Double profit = calculateProfit(costs, revenue);\n    final Long profitDuration =\n            new Date().getTime() - beforeProfit.getTime();\n    System.out.println(\n            \"Profit calculation took \" + profitDuration + \" ms\");\n\n    return profit;\n\n  }\n\n\n  private static Double calculateCosts() {\n    pretendToWorkHard();\n    return 4567.3;\n  }\n\n  private static Double calculateRevenue() {\n    pretendToWorkHard();\n    return 23413.2;\n  }\n\n  private static Double calculateProfit(Double costs, Double revenue) {\n    pretendToWorkHard();\n    return revenue - costs;\n  }\n\n  private static final Random r = new Random();\n  private static final Integer MAX_WORK_TIME_MS = 200;\n\n  private static void pretendToWorkHard() {\n    try {\n      Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n    } catch (InterruptedException e) {\n        System.out.println(\"Work was interrupted. Exception message: \" + \n            e.getMessage());\n    }\n  }\n}\n","ProfitTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class ProfitTest {\n\n    @Test\n    public void ProfitBefore_should_calculate_profits() {\n        assertEquals(18845.9, ProfitBefore.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitNaive_should_calculate_profits() {\n        assertEquals(18845.9, ProfitNaive.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitDeduplicate_should_calculate_profits() {\n        assertEquals(18845.9, ProfitDeduplicate.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitGeneralize_should_calculate_profits() {\n        assertEquals(18845.9, ProfitGeneralize.calculate(), 0.001);\n    }\n\n    @Test\n    public void ProfitIsolation_should_calculate_profits() {\n        assertEquals(18845.9, ProfitIsolation.calculate(), 0.001);\n    }\n\n}\n","ProfitDeduplicate.java":"\nimport java.util.Random;\n\npublic class ProfitDeduplicate {\n    public static Double calculate() {\n\n        final Double costs = Timing.timedDouble(\n                \"Cost calculation\",\n                ProfitDeduplicate::calculateCosts);\n\n        final Double revenue = Timing.timedDouble(\n                \"Revenue calculation\",\n                () -> calculateRevenue());\n\n        final Double profit = Timing.timedDouble(\n                \"Profit calculation\",\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 200;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            System.out.println(\"Work was interrupted. Exception message: \" + \n                e.getMessage());\n        }\n    }\n}\n","Timing.java":"\nimport java.util.Date;\nimport java.util.function.Supplier;\nimport java.util.function.Consumer;\n\npublic class Timing {\n\n    public static Double timedDouble(String description, \n            Supplier<Double> code) {\n        final Date before = new Date();\n        final Double result = code.get();\n        final Long duration = new Date().getTime() - before.getTime();\n        System.out.println(description + \" took \" + duration + \" ms\");\n        return result;\n    }\n\n    public static <A> A timed(String description,\n                              Supplier<A> code) {\n        // final Consumer<String> defaultPrinter = System.out::println;\n\n        // change default to do nothing \n        final Consumer<String> defaultPrinter = (s) -> {};  \n\n        return timed(description, defaultPrinter, code);\n    }\n\n    public static <A> A timed(String description,\n                              Consumer<String> printer,\n                              Supplier<A> code) {\n        final Date before = new Date();\n\n        final A result = code.get();\n\n        final Long duration = new Date().getTime() - before.getTime();\n        printer.accept(description + \" took \" + duration + \" ms\");\n        return result;\n    }\n}\n","ProfitGeneralize.java":"\nimport java.util.Random;\n\npublic class ProfitGeneralize {\n    public static Double calculate() {\n\n        final Double costs = Timing.timed(\n                \"Cost calculation\",\n                ProfitGeneralize::calculateCosts);\n\n        final Double revenue = Timing.timed(\n                \"Revenue calculation\",\n                ProfitGeneralize::calculateRevenue);\n\n        final Double profit = Timing.timed(\n                \"Profit calculation\",\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 2000;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n            System.out.println(\"Work was interrupted. Exception message: \" + \n                e.getMessage());\n        }\n    }\n}\n","ProfitIsolation.java":"\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\nimport java.util.Random;\n\n\npublic class ProfitIsolation {\n    static final Logger logger = \n        Logger.getLogger(ProfitIsolation.class.getName());\n\n    public static Double calculate() {\n\n        final Double costs = Timing.timed(\n                \"Cost calculation\",\n                ProfitIsolation::calculateCosts);\n\n        final Double revenue = Timing.timed(\n                \"Revenue calculation\",\n                ProfitIsolation::calculateRevenue);\n\n        final Double profit = Timing.timed(\n                \"Profit calculation\",\n                logger::info,\n                () -> calculateProfit(costs, revenue));\n\n        return profit;\n\n    }\n\n\n    private static Double calculateCosts() {\n        pretendToWorkHard();\n        return 4567.3;\n    }\n\n    private static Double calculateRevenue() {\n        pretendToWorkHard();\n        return 23413.2;\n    }\n\n    private static Double calculateProfit(Double costs, Double revenue){\n        pretendToWorkHard();\n        return revenue - costs;\n    }\n\n    private static final Random r = new Random();\n    private static final Integer MAX_WORK_TIME_MS = 2000;\n    private static void pretendToWorkHard() {\n        try {\n            Thread.sleep(r.nextInt(MAX_WORK_TIME_MS));\n        } catch (InterruptedException e) {\n        }\n    }\n}\n"}